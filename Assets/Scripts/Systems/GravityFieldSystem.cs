using Unity.Entities;
using Unity.Physics;
using Unity.Physics.Systems;
using Unity.Mathematics;
using Unity.Burst;
using Unity.Jobs;
using Unity.Transforms;
using Unity.Collections;
using System;
using static Unity.Physics.BoundingVolumeHierarchy;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.Rendering;
using System.Threading;

[BurstCompile]
[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]
[UpdateAfter(typeof(BuildPhysicsWorld))]
[UpdateBefore(typeof(StepPhysicsWorld))]
public class GravityFieldSystem : SystemBase, IPhysicsSystem
{
    public enum GravityImpl: ushort
    {
        GRAVITY_TREE_CPU, // O(N log N) Multipole algorithm based on Barnes-Hutt with a simple MAC
        GRAVITY_PARTICLE_CPU, // O(N^2) Brute force gravity on CPU
        GRAVITY_PARTICLE_GPU
    };

    public const GravityImpl k_GravityImpl = GravityImpl.GRAVITY_PARTICLE_GPU;
    public const float k_GravConstant = 1.0f;

    private StepPhysicsWorld m_StepPhysicsWorld;

    // Used for GPU Gravity
    ComputeShader Shader = null;
    int Kernel;
    uint threadGroupSize;
    public static ComputeBuffer resultBuffer;
    public NativeArray<Vector4> output;
    int vectorLength = 100;
    public static GraphicsFence Fence;
    public static AsyncGPUReadbackRequest AsyncRequest;
    private static Semaphore gpuwait;

    // IPhysicsSystem interface
    // Output Dependency is what you wait on if you need our jobs to run before you
    // If you need to use data generated by our jobs, register your job as an input
    // dependency so we wait for you
    private JobHandle InputDependency;
    private JobHandle OutputDependency;
    public JobHandle GetOutputDependency() => OutputDependency;
    public void AddInputDependency(JobHandle jh) => InputDependency = JobHandle.CombineDependencies(jh, InputDependency);

    protected override void OnCreate()
    {
        var world = World.DefaultGameObjectInjectionWorld;
        m_StepPhysicsWorld = world.GetOrCreateSystem<StepPhysicsWorld>();

        InputDependency = default;
        OutputDependency = default;
        if(k_GravityImpl == GravityImpl.GRAVITY_PARTICLE_GPU)
        {
            Shader = Resources.Load<ComputeShader>("ParticleGravity");
            Kernel = Shader.FindKernel("CSMain");
            Shader.GetKernelThreadGroupSizes(Kernel, out threadGroupSize, out _, out _);
            resultBuffer = new ComputeBuffer(vectorLength, sizeof(float) * 4);
            gpuwait = new Semaphore(0, 1);
            output = new NativeArray<Vector4>(vectorLength, Allocator.Persistent);
        }
    }

    protected override void OnDestroy()
    {
        Cleanup();
        if (k_GravityImpl == GravityImpl.GRAVITY_PARTICLE_GPU)
        {
            resultBuffer.Dispose();
        }
    }

    protected void Cleanup()
    {
        OutputDependency.Complete();
        InputDependency.Complete();

        // reset our input dependency so we can start collecting for the next frame
        InputDependency = default;
    }

    protected override void OnUpdate()
    {
        switch(k_GravityImpl)
        {
            case GravityImpl.GRAVITY_TREE_CPU:
                OnUpdateTree();
                break;
            case GravityImpl.GRAVITY_PARTICLE_CPU:
                OnUpdateParticle();
                break;
            case GravityImpl.GRAVITY_PARTICLE_GPU:
                OnUpdateParticleGPU();
                break;
        }
    }



    public void OnUpdateTree()
    {
        Cleanup();

        m_StepPhysicsWorld.EnqueueCallback(SimulationCallbacks.Phase.PostBroadphase,
            (ref ISimulation sim, ref PhysicsWorld pw, JobHandle inputDeps) =>
            {
                // A little paranoid since we're attaching to a custom callback that only exists
                // in modified unity physics
                if (sim.Type != SimulationType.UnityPhysics)
                {
                    throw new NotImplementedException("SPH KernelSystem Only works with Unity Physics");
                }

                // Get the tree!!
                // I'm doing it this way rather than using "Tree" because
                // I am hoping that iterating the unsafe way similar to the collisiosn algorithms
                // is better for performance, and that is why Unity drops to pointers for traversing
                // these structures.
                BoundingVolumeHierarchy BVH = new BoundingVolumeHierarchy(
                    pw.CollisionWorld.Broadphase.DynamicTree.Nodes,
                    pw.CollisionWorld.Broadphase.DynamicTree.NodeFilters);
                int numNodes = pw.CollisionWorld.Broadphase.DynamicTree.Nodes.Length;

                // bodies in broadphase are m_Bodies
                // m_bodies is set up as [[dynamic bodies][Static bodies...]]
                // 
                // The dynamic tree is only over dynamic bodies, likewise for static
                // Indicies in tree are within the sub-array, not overal bodies.
                // For dynamic bodies these are the same indicies, since dynamic bodies are first
                //
                // Leaf processors receive indicies for the index space
                //
                // None of the collision/distance algorithms I'm seeing let one stop processing
                // at a non-leaf node, they are all full traversals, so we need our own

                NativeArray<GravitationalMoment> moments = new NativeArray<GravitationalMoment>(numNodes, Allocator.TempJob);
                NativeArray<RigidBody> bodies = pw.Bodies;
                var massData = GetComponentDataFromEntity<ParticleMass>(true);
                var translationData = GetComponentDataFromEntity<Translation>(true);

                // Annotate the tree with gravity
                var GenerateMomentsSTJob = new GenerateMomentsSTJob
                {
                    // Inputs:
                    ParticleTree = BVH,
                    Bodies = pw.Bodies,
                    MassData = massData,
                    TranslationData = translationData,

                    // Need a place to stick the moments
                    Moments = moments,
                };
                inputDeps = GenerateMomentsSTJob.Schedule(inputDeps);

                // Second things second, treewalk per particle
                // First version: Walk the tree to leaves, evaluate at leaves
                // Second version: Check intermediate nodes and use prior data
                var particleGravityJob = Entities
                .WithReadOnly(bodies)
                .WithReadOnly(massData)
                .WithReadOnly(translationData)
                .WithReadOnly(moments)
                .WithDisposeOnCompletion(moments)
                .ForEach((
                    ref GravityField grav_i,
                    in Translation translation_i,
                    in ParticleSmoothing smoothing) =>
                {
                    float a = smoothing.h;
                    float3 r_i = translation_i.Value.xyz;
                    float4 gravity = float4.zero;

                    int numParticlesUsed = 0;
                    int numApproximationsUsed = 0;

                    unsafe
                    {
                        // For this particle again do a depth-first treewalk
                        int* binaryStack = stackalloc int[Constants.BinaryStackSize];
                        int* stack = binaryStack;

                        // Push the top of BVH (index 1?) onto the stack
                        *stack++ = 1;

                        do
                        {
                            // Pop the stack, repeatedly until empty:
                            int nodeIndex = *(--stack);
                            Node* node = BVH.m_Nodes + nodeIndex;

                            // Get the moment for this node
                            GravitationalMoment moment = moments[nodeIndex];

                            // If this node's approximation is good-enough,
                            // Calculate its contribution to gravity and add that in.
                            if (AcceptApproximation(r_i, moment, node->Bounds.GetCompoundAabb()))
                            {
                                gravity += moment.GravityContribution(r_i);
                                numApproximationsUsed++;
                            }
                            else if (node->IsLeaf)
                            {
                                // If we are a leaf node, and we cannot accept the approximation,
                                // Compute gravity from our constituent rigid bodies
                                bool4 validMask = node->AreLeavesValid;
                                int4 validBodies;
                                int validBodiesCount = math.compress((int*)(&validBodies), 0, node->Data, validMask);
                                for (int i = 0; i < validBodiesCount; i++)
                                {
                                    //   Compute the gravity contribution of the selected body on the particle
                                    int rigidBodyIndex = validBodies[i];
                                    RigidBody rigidBody = bodies[rigidBodyIndex];
                                    Entity e = rigidBody.Entity;
                                    float3 r_j = translationData[e].Value.xyz;
                                    float m = massData[e].Value;

                                    //   Add this to the running sums of grav potential and field strength
                                    gravity += GravityContributionParticle(r_i, r_j, m, a);
                                    numParticlesUsed++;
                                }
                            }
                            else
                            {
                                // We are a non-leaf node and cannot accept the approximation,
                                // continue traversal by pushing all valid children on the stack
                                bool4 childrenMask = node->AreInternalsValid;
                                int4 validChildren;
                                int childrenCount = math.compress((int*)(&validChildren), 0, node->Data, childrenMask);

                                *((int4*)stack) = validChildren;
                                stack += childrenCount;
                            }
                        } while (stack > binaryStack);
                    }
                    // When we have exhausted the queue write out the particle gravity contribution
                    grav_i.Value = gravity;
                    grav_i.numParticles = numParticlesUsed;
                    grav_i.numApprox = numApproximationsUsed;
                });
                var scheduledJobHandle = particleGravityJob.ScheduleParallel(inputDeps);
                
                OutputDependency = scheduledJobHandle;
                return scheduledJobHandle;
            });
    }


    // The algorithm we will start with here looks at the angle subtended by the 
    // bounding volume associated with the relevant moment. It needs to look at
    // the angle in relation to a field point r_i
    //
    // Using the Bmax Algorithm from "Skeletons in the Treecode Closet" (Salmon & Warren 1993)
    public const float k_Theta = 0.7f;
    public static bool AcceptApproximation(float3 r_i, GravitationalMoment moment, Aabb boundingVolume)
    {
        // Field point displacement
        float3 displacement = r_i - moment.CenterOfMass;
        float r_sq = math.dot(displacement, displacement);

        // This gives positive components of a vector from CM to the farthest corner of Aabb
        float3 bMax_positive = 
            math.max(
            // along each axis positive distance from CM to upper bound
            boundingVolume.Max - moment.CenterOfMass, 
            // along each axis positive distance from CM to lower bound
            moment.CenterOfMass - boundingVolume.Min);

        float bmax_sq = math.dot(bMax_positive, bMax_positive);
        
        // Compare lengths avoiding sqrt
        return bmax_sq/r_sq < k_Theta*k_Theta;
    }

    public void OnUpdateParticle()
    {
        Cleanup();

        m_StepPhysicsWorld.EnqueueCallback(SimulationCallbacks.Phase.PostCreateDispatchPairs,
            (ref ISimulation sim, ref PhysicsWorld pw, JobHandle inputDeps) =>
            {
                // Entity query that will give us only entities which have all three
                // we will eventually need ParticleSmoothing for variable smoothing lengths, but do not use it now.
                var gravParticleQuery = GetEntityQuery(typeof(ParticleMass), typeof(ParticleSmoothing), typeof(Translation));

                var entityDataLocal = gravParticleQuery.ToEntityArray(Allocator.TempJob);
                var massData = GetComponentDataFromEntity<ParticleMass>(true);
                var translationData = GetComponentDataFromEntity<Translation>(true);

                inputDeps = Entities
                    .WithReadOnly(massData)
                    .WithReadOnly(translationData)
                    .WithReadOnly(entityDataLocal)
                    .WithDisposeOnCompletion(entityDataLocal)
                    .ForEach((Entity i,
                        ref GravityField grav_i, // Should be write-only
                        in ParticleSmoothing smoothing_i,
                        in Translation translation_i) =>
                    {
                        float4 gravity = float4.zero;
                        float3 r_i = translation_i.Value;

                        // We're going to assume constant smoothing length for now
                        // TODO: Variable smoothing lengths. Options:
                        //       - Arbitrary symmetrization
                        //       - Dyer & Ip Uniform Density Sphere formula
                        //       - Switching to Price/Monaghan Kernel softening method
                        float a = smoothing_i.h;

                        foreach (Entity particle_j in entityDataLocal)
                        {
                            // Skip self-contribution
                            if (particle_j == i)
                            {
                                // Todo: Add in self-contribution for potential?
                                continue;
                            }

                            float3 r_j = translationData[particle_j].Value;
                            float m = massData[particle_j].Value;
                            gravity += GravityContributionParticle(r_i, r_j, m, a);
                        }

                        grav_i.Value = gravity;
                    }).ScheduleParallel(inputDeps);
                OutputDependency = inputDeps;
                return inputDeps;
            });
    }

    public void OnUpdateParticleGPU()
    {
        Cleanup();

        m_StepPhysicsWorld.EnqueueCallback(SimulationCallbacks.Phase.PostCreateDispatchPairs,
            (ref ISimulation sim, ref PhysicsWorld pw, JobHandle inputDeps) =>
            {
                // Need to figure out how to pull this out of scheduling
                // Perform at correct time when input data is available and up to date
                // For now test data so we don't care
                CommandBuffer commandBuffer = new CommandBuffer();

                commandBuffer.SetExecutionFlags(CommandBufferExecutionFlags.AsyncCompute);
                //Shader.SetBuffer(Kernel, "Result", resultBuffer);
                commandBuffer.SetComputeBufferParam(Shader, Kernel, "Result", resultBuffer);
                
                int threadGroups = (int)((vectorLength + (threadGroupSize - 1)) / threadGroupSize);
                // I think this tells the GPU to start. There is no input data to 
                // write out to GPU yet
                //Shader.Dispatch(Kernel, threadGroups, 1, 1);
                commandBuffer.DispatchCompute(Shader, Kernel, threadGroups, 1, 1);

                /*
                GravityFieldSystem.Fence = commandBuffer.CreateGraphicsFence(
                    GraphicsFenceType.AsyncQueueSynchronisation, 
                    SynchronisationStageFlags.ComputeProcessing);
                */
                
                Graphics.ExecuteCommandBufferAsync(commandBuffer, ComputeQueueType.Urgent);

                Action<AsyncGPUReadbackRequest> gpuFinishedCallback = 
                new Action<AsyncGPUReadbackRequest>((AsyncGPUReadbackRequest req) =>
                {
                    Debug.Log("Releasing semaphore");
                    output = req.GetData<Vector4>();
                    gpuwait.Release();
                });

                var collectJob = new CollectDataJob {
                    output = output,
                };
                inputDeps = collectJob.Schedule(inputDeps);

                AsyncRequest = AsyncGPUReadback.Request(resultBuffer, gpuFinishedCallback);
                
                //AsyncRequest = AsyncGPUReadback.RequestIntoNativeArray( ref output, resultBuffer, gpuFinishedCallback);

                return inputDeps;
            });
    }

#region P2P Calculation
    // Returns a packed float4 with the gravitational contribution of point r_j with mass m on a point r_i
    // The packed float4 is xyz => Gradient of Gravitational potential, w => gravitational potential.
    // Inputs:
    // r_i -> float3 world position of field point
    // r_j -> float3 world position of point particle
    // m -> mass of point particle
    // a -> Smoothing constant for close-in approximation
    //
    // About the calculation:
    // - Use a uniform-density model for the particles, with their smaller smoothing length "h" as the characteristic particle size a
    //   The force law is Equation 8 from "Softening in N-body Simulations of CollisionLes systems" (1993, Dyer & Ip)
    //
    // - Note: This choice of model means we don't use the output of the density system
    //
    //   Force law for r >= a:
    //   |F_grav| = (G*M*M)/(r^2)
    //
    //   Force law for r <= a:
    //   x = r/a
    //   |F_grav| = ((G*M*M*x)/(a^2))*(8 - 9x + 2x^3)
    //
    // - Store the gravity field vector g, and the gravitational potential phi
    // - Some assumptions we use now:
    //    G = 1
    //    F_grav(vec) = m * g(vector)
    //    - Gradient(phi) = g(vector)
    public static float4 GravityContributionParticle(float3 r_i, float3 r_j, float m, float a)
    {
        float3 displacement = r_i - r_j;
        float r = math.length(displacement);
        float grav_mag_over_r;
        float grav_potential;

        if (r < a)
        {
            float x = r / a;
            float x_sq = x * x;
            float x_cube = x_sq * x;
            float x_5th = x_sq * x_cube;
            grav_mag_over_r = (m / (a * a * a)) * (8.0f - 9.0f * x + 2.0f * x_cube);
            grav_potential = -(m / a) * (2.4f - 4.0f * x_sq + 3.0f * x_cube - 0.4f * x_5th);
        }
        else
        {
            grav_mag_over_r = m / (r * r * r);
            grav_potential = -(m / r);
        }

        float3 grav_potential_gradient = displacement * grav_mag_over_r;
        return new float4(k_GravConstant * grav_potential_gradient, k_GravConstant * grav_potential);
    }
    #endregion

#region Moment Calculations (M2P, M2M, P2M)
    // A gravitational moment corresponding to mass in some bounding volume
    //
    // Stores the center of mass in world coordinates and
    // the first moment (mass for point approximation)
    // in a packed float4.
    //
    // The structure supports accumulating moments onto it, unless it is marked final
    public struct GravitationalMoment
    {
        private float4 m_packedCMfirstMoment;
        private bool m_complete;

        public GravitationalMoment(float3 CM, float firstMoment)
        {
            m_packedCMfirstMoment = new float4(CM, firstMoment);
            m_complete = false;
        }

        public void Complete()
        {
            m_complete = true;
        }
        public bool IsComplete() => m_complete;

        public float3 CenterOfMass
        {
            get => m_packedCMfirstMoment.xyz;
        }
        public float MonopoleMoment
        {
            get => m_packedCMfirstMoment.w;
        }


        // P2M calculation
        // Accumulates a point mass of with the relevant CM and firstMoment (mass) onto the
        // Moment structure
        // TODO: Interface will likely change here as gravity changes 
        public void Accumulate(float3 CM, float firstMoment)
        {
            if (IsComplete())
            {
                throw new InvalidOperationException("Cannot accumulate moment on a finalized GravitaitonalMoment");
            }

            if (firstMoment != 0.0f)
            {
                float newMoment = MonopoleMoment + firstMoment;
                float3 newCM = (CenterOfMass * MonopoleMoment + CM * firstMoment) / newMoment;
                m_packedCMfirstMoment = new float4(newCM, newMoment);
            }
        }

        // M2M calculation
        // For now this is really basic, because of first moments, but this funtion
        // aggregates multiple moments into a single representation.
        public void Accumulate(GravitationalMoment moment)
        {
            Accumulate(moment.CenterOfMass, moment.MonopoleMoment);
        }

        
        // M2P calculation
        //
        // Calculate the net gravitaitonal contribution of a GravitationalMoment structure on a field point r_i
        // We do not bother with smoothing lengths for now because this assumed to be "far enough away" that
        // smoothing length isn't an issue
        // The packed float4 returned is xyz => Gradient of Gravitational potential, w => gravitational potential.
        public float4 GravityContribution(float3 r_i)
        {
            float3 displacement = r_i - CenterOfMass;
            float m = MonopoleMoment;
            float r = math.length(displacement);
            float grav_mag_over_r;
            float grav_potential;

            grav_mag_over_r = m / (r * r * r);
            grav_potential = -(m / r);

            float3 grav_potential_gradient = displacement * grav_mag_over_r;

            return new float4(k_GravConstant * grav_potential_gradient, k_GravConstant * grav_potential);
        }
    }

    #endregion

#region Moment Job
    // This is going to iterate the whole tree and add up moments for the relevant node
    // For now Single Threaded:
    //     If want to multithread: Look at CollisionWorld.cs, Broadphase.cs and BoundingVolumeHierarcy.cs for examples
    //     May be possible to process queue in parallel, but it also may be slower to do it that way.
    // TODO: Look at burst optimizations in other Unity.Physics tree code
    [BurstCompile(OptimizeFor = OptimizeFor.Performance, DisableSafetyChecks = true)]
    struct GenerateMomentsSTJob: IJob
    {
        // Input
        [ReadOnly, NativeDisableUnsafePtrRestriction] public BoundingVolumeHierarchy ParticleTree;
        [ReadOnly] public NativeArray<RigidBody> Bodies;
        [ReadOnly] public ComponentDataFromEntity<ParticleMass> MassData;
        [ReadOnly] public ComponentDataFromEntity<Translation> TranslationData;

        // Output
        public NativeArray<GravitationalMoment> Moments;

        public unsafe void Execute()
        {
            int* binaryStack = stackalloc int[Constants.BinaryStackSize];
            int* stack = binaryStack;

            // Push the top of BVH (index 1?) onto the stack
            *stack++ = 1;

            // Pop the stack, repeatedly until empty:
            do
            {
                int nodeIndex = *(--stack);
                Node* node = ParticleTree.m_Nodes + nodeIndex;

                GravitationalMoment moment = Moments[nodeIndex];
             
                // If we are a leaf node:
                if (node->IsLeaf)
                {
                    //  Go across rigid bodies:
                    //    Lookup from rigid body index in tree -> entity -> Mass component data
                    //      (can we get speedup by pre-computing this lookup?)
                    //    Assemble relevant moments for this object at center-of mass for the leaf (averaging 4 particles)
                    //    Store them in the appropriate spot in Moments array    
                    bool4 validMask = node->AreLeavesValid;
                    int4 validBodies;
                    int validBodiesCount = math.compress((int*)(&validBodies), 0, node->Data, validMask);
                    for (int i = 0; i < validBodiesCount; i++)
                    {
                        //   Compute the gravity contribution of the selected body on the particle
                        int rigidBodyIndex = validBodies[i];
                        RigidBody rigidBody = Bodies[rigidBodyIndex];
                        Entity e = rigidBody.Entity;
                        float3 r_j = TranslationData[e].Value.xyz;
                        float m = MassData[e].Value;
                        moment.Accumulate(r_j, m);
                    }
                    moment.Complete();
                }
                // If we are a non-leaf node:
                else
                {
                    // Get valid and uncomputed children
                    bool4 validMask = node->AreInternalsValid;
                    bool4 uncomputedChildrenMask = UncomputedMoments(node->Data, validMask);
                    if (uncomputedChildrenMask.Equals(false))
                    {
                        // All children have a moment, we're good to calculate this node.
                        int4 validChildren;
                        int validChildrenCount = math.compress((int*)(&validChildren), 0, node->Data, validMask);
                        for ( int i = 0; i< validChildrenCount; i++)
                        {
                            // Calculate our moment from children's moments
                            // Store the moment and center-of-mass in the corresponding place in Moments array
                            moment.Accumulate(Moments[validChildren[i]]);
                        }
                        moment.Complete();
                    }
                    else
                    {
                        // Need to compute child moments before we can compute our own moment
                        int4 uncomputedChildren;
                        int uncomputedChildrenCount = math.compress((int*)(&uncomputedChildren), 0, node->Data, uncomputedChildrenMask);
                 
                        // Push us on the stack for later processing after our children
                        *stack++ = nodeIndex;

                        // Push uncomputed children on stack, so they will compute before us
                        *((int4*)stack) = uncomputedChildren;
                        stack += uncomputedChildrenCount;
                    }
                }
                Moments[nodeIndex] = moment;
            } while (stack > binaryStack);
        }

        // returns a mask that has true for uncomputed momments
        // relies on validMask to be false for any index which we shouldn't look up.
        public unsafe bool4 UncomputedMoments (int4 indicies, bool4 validMask)
        {
            bool4 retval = false;
            for (int i=0; i < 4; i++)
            {
                if(validMask[i])
                {
                    retval[i] = !(Moments[indicies[i]].IsComplete());
                }
            }
            return retval;
        }
    }
    #endregion

#region  GPU Jobs

    struct CollectDataJob : IJob
    {
        [ReadOnly]
        public NativeArray<Vector4> output;
        public void Execute()
        {
            // TODO: is there an API in Unity equivalent to vkWaitForFences
            // Thats what is really wanted here.
            // Thankfully, this is a worker thread so sleeping for a few ms should
            // hopefully not impact overall efficiency by much if there are enough 
            // workers to keep the CPU busy.
            Debug.Log("Waiting on Semaphore");
            TimeSpan timeout = new TimeSpan(0, 0, 1);
            if (! gpuwait.WaitOne(timeout)) {
                Debug.Log("Timed out waiting for GPU");
                return;
            }


            // If we got here, data should be in the output buffer already

            Debug.Log("Shader output first 5");
            for (int i = 0; i < 5; i++)
            {
                Debug.Log(output[i]);
            }
            Debug.Log("Shader output last 5");
            for (int i = output.Length - 5; i < output.Length; i++)
            {
                Debug.Log(output[i]);
            }
        }
    }
#endregion
}